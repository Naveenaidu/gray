The dimensions for high res sphere! use this when you want to take pictures.

----- High res sphere -------

func main() {
	canvas := world.NewCanvas(500, 500, *world.Black)

	sphere := material.UnitSphere()
	sphere.Transform = *geom.ChainTransforms([]*geom.Matrix{
		geom.ScaleM(100, 100, 100),
		geom.TranslationM(250, 250, 0),
	})
	sphere.Material = material.DefaultMaterial()
	sphere.Material.Color = *world.NewColor(1, 0.2, 1)

	// assumed ray origin
	rayOrigin := geom.NewPoint(250, 250, 250)

	lightPosition := geom.NewPoint(-20, 50, 200)
	lightColor := world.NewColor(1, 1, 1)
	light := lighting.NewLight(*lightColor, *lightPosition)

	for h := 0; h < canvas.Height; h++ {
		for w := 0; w < canvas.Width; w++ {
			pixel := geom.NewPoint(float64(w), float64(h), 0.0)
			rayDirection := pixel.Subtract(*rayOrigin).Normalize()
			ray := rayt.Ray{Origin: *rayOrigin, Direction: *rayDirection}

			// TODO: A better interface possible ?
			// Intersect the ray with sphere
			intersections := ray.IntersectSphere(*sphere)
			hit := ray.Hit(intersections)

			if hit != nil {
				// for now, just color the pixel where the ray hit
				point := ray.Position(hit.T)
				normal := lighting.NormalAt(hit.Object, *point)
				eye := ray.Direction.Reverse()
				color := lighting.Lighting(hit.Object.Material, light, *point, *eye, normal)

				canvas.WritePixel(int(pixel.X), int(pixel.Y), color)
			}

		}
	}

	canvas.WriteToPPM("circle.ppm")
}


----- Quick res sphere ----

func main() {
	canvas := world.NewCanvas(100, 100, *world.Black)

	sphere := material.UnitSphere()
	sphere.Transform = *geom.ChainTransforms([]*geom.Matrix{
		geom.ScaleM(30, 30, 30),
		geom.TranslationM(50, 50, 0),
	})
	sphere.Material = material.DefaultMaterial()
	sphere.Material.Color = *world.NewColor(1, 0.2, 1)

	// assumed ray origin
	rayOrigin := geom.NewPoint(50, 50, 50)

	lightPosition := geom.NewPoint(-5, 5, 55)
	lightColor := world.NewColor(1, 1, 1)
	light := lighting.NewLight(*lightColor, *lightPosition)

	for h := 0; h < canvas.Height; h++ {
		for w := 0; w < canvas.Width; w++ {
			pixel := geom.NewPoint(float64(w), float64(h), 0.0)
			rayDirection := pixel.Subtract(*rayOrigin).Normalize()
			ray := rayt.Ray{Origin: *rayOrigin, Direction: *rayDirection}

			// TODO: A better interface possible ?
			// Intersect the ray with sphere
			intersections := ray.IntersectSphere(*sphere)
			hit := ray.Hit(intersections)

			if hit != nil {
				// for now, just color the pixel where the ray hit
				point := ray.Position(hit.T)
				normal := lighting.NormalAt(hit.Object, *point)
				eye := ray.Direction.Reverse()
				color := lighting.Lighting(hit.Object.Material, light, *point, *eye, normal)

				canvas.WritePixel(int(pixel.X), int(pixel.Y), color)
			}

		}
	}

	canvas.WriteToPPM("circle.ppm")
}
